'use strict';

const _sinon = require('sinon');
const _chai = require('chai');
_chai.use(require('sinon-chai'));
_chai.use(require('chai-as-promised'));
const expect = _chai.expect;

const _clone = require('clone');
const LambdaContext = require('./lambda-context');
const ConfigMockBuilder = require('../config-mock-builder');
const LoggerMockBuilder = require('../logger-mock-builder');

/**
 * Class that provides a wrapper around lambda handlers, and exposes utility
 * methods that can be used during testing.
 */
class LambdaWrapper {
    /**
     * @param {Object} handler Reference to the lambda handler.
     * @param {Object} [event={}] The event object to pass to the handler
     *        when invoked.
     * @param {Object} [contextProps = {
     *            functionName: "__lambda_function_name__",
     *            alias: null
     *        } ] Additional context info that will be used to generate the
     *        lambda context. If omitted, a default object will be generated.
     *        If the functionName property begins with "arn:", it will be
     *        used as specified. Otherwise, the name will be appended to an
     *        autogenerated arn prefix.
     * @param {Object} [configProps={}] Optional config parameters passed to the
     *        lambda as a part of the mock config object
     */
    constructor(handler, event, contextProps, configProps) {
        if(typeof handler !== 'function') {
            throw new Error('Invalid handler specified (arg #1)');
        }
        if(!event || typeof event !== 'object') {
            event = {};
        }
        if(!contextProps || contextProps instanceof Array ||
            typeof contextProps !== 'object') {
            contextProps = {};
        }
        if(!configProps || configProps instanceof Array ||
            typeof configProps !== 'object') {
            configProps = {};
        }
        this._handler = handler;
        this._event = _clone(event);
        this._contextProps = _clone(contextProps);
        this._configProps = _clone(configProps);

        const wrapper = {
            _callback: function() {}
        }
        this._invokePromise = new Promise((resolve, reject) => {
            this._callback = _sinon.stub(wrapper, '_callback', (err, data) => {
                if(err) {
                    reject(err);
                    return;
                }
                resolve(data);
            });
        });
    }


    /**
     * Initializes the extension object.
     *
     * @private
     *
     * @param {Object} [props={}] Optional config props object that can be used
     *        to set properties for the lambda.
     * @param {String} env Environment string to use for the extension object.
     */
    _initExt(configProps, env) {
        const logger = (new LoggerMockBuilder()).mock;
        const config = (new ConfigMockBuilder(configProps)).mock;

        return {
            logger,
            config,
            env
        };
    }

    /**
     * Appends the specified properties to the existing input (event) object.
     * Any existing properties in the input with the same name will be
     * overwritten.
     *
     * @param {Object} properties A map of input properties be added to the
     *        existing event object.
     *
     * @return {Object} A reference to the wrapper object - can be used to chain
     *         calls.
     */
    addEventProperties(properties) {
        if(!properties || (properties instanceof Array) || typeof properties !== 'object') {
            throw new Error('Invalid event properties specified (arg #1)');
        }

        this._event = Object.assign(this._event, _clone(properties));
        return this;
    }

    /**
     * Adds a config property to the wrapper. These properties will be
     * accessible to the lambda via the ext.config object. Any existing
     * properties with the same name will be overwritten.
     *
     * @param {Object} properties A map of input properties be added to the
     *        existing input object.
     *
     * @return {Object} A reference to the wrapper object - can be used to chain
     *         calls.
     */
    addConfigProperties(properties) {
        if(!properties || (properties instanceof Array) || typeof properties !== 'object') {
            throw new Error('Invalid config properties specified (arg #1)');
        }

        this._configProps = Object.assign(this._configProps, _clone(properties));
        return this;
    }

    /**
     * Adds a context property to the wrapper. Any existing properties with the
     * same name will be overwritten.
     *
     * @param {Object} properties A map of input properties be added to the
     *        existing input object.
     *
     * @return {Object} A reference to the wrapper object - can be used to chain
     *         calls.
     */
    addContextProperties(properties) {
        if(!properties || (properties instanceof Array) || typeof properties !== 'object') {
            throw new Error('Invalid context properties specified (arg #1)');
        }

        this._contextProps = Object.assign(this._contextProps, _clone(properties));
        return this;
    }

    /**
     * Sets the name of the lambda function. This value is passed to the
     * handler via the lambda context argument. Not setting the function name
     * will result in a default function name being used, which should be ok
     * for most use cases.
     *
     * @param {String} functionName The name of the function to assign. If a
     *        valid ARN string not passed, a default ARN will be generated
     *        using the function name. Note that if an ARN is used, the alias
     *        must not be specified with the function name.
     *
     * @return {Object} A reference to the wrapper object - can be used to chain
     *         calls.
     */
    setFunctionName(functionName) {
        if(typeof functionName !== 'string' || functionName.length <= 0) {
            throw new Error('Invalid function name specified (arg #1)');
        }

        this._contextProps.functionName = functionName;
        return this;
    }

    /**
     * Sets the environment for the lambda function. The lambda handler derives
     * environment values from the function alias, and this property will be
     * set as the function alias so that handler derives the environment
     * string correctly.
     *
     * @param {String} env The environment string that will be used as the
     *        function alias when the lambda function is invoked.
     *
     * @return {Object} A reference to the wrapper object - can be used to chain
     *         calls.
     */
    setEnvironment(env) {
        if(typeof env !== 'string' || env.length <= 0) {
            throw new Error('Invalid environment string specified (arg #1)');
        }

        this._contextProps.alias = env;
        return this;
    }

    /**
     * Returns a reference to the callback spy that is passed to the lambda
     * function.
     */
    get callback() {
        return this._callback;
    }

    /**
     * Returns a reference to the raw context properties that will be used to
     * generate the lambda function context.
     */
    get contextProps() {
        return this._contextProps;
    }

    /**
     * Returns a reference to the raw config properties that will be passed to
     * the lambda function as the config object at invocation time.
     */
    get configProps() {
        return this._configProps;
    }

    /**
     * Returns a reference to the event object that is passed to the lambda
     * function.
     */
    get event() {
        return this._event;
    }

    /**
     * Returns a reference to the lambda function handler.
     */
    get handler() {
        return this._handler;
    }

    /**
     * Invokes the lamdba function with predefined event, context and callback
     * values.
     */
    invoke() {
        const context = new LambdaContext(this.contextProps);
        const ext = this._initExt(this.configProps, context.env);
        this.handler(this.event, context.context, this.callback, ext);
        return this._invokePromise;
    }

    /**
     * Invokes the lamdba function, and evaluates the callback function for
     * invocation with specific errors.
     *
     * @param {Object} error Reference to the expected error when the lambda
     *        function is invoked. This could be a string, a RegExp object, or
     *        an error type.
     * @param {Object} [message] An optional error message which will only be
     *        considered if the previous argument is an error type.
     *
     * @param {Object} errorArg The error argument received from the callback.
     */
    testError(error, message) {
        this.callback.reset();
        this.invoke();

        expect(this.callback).to.have.been.calledOnce;

        const errorMessage = (typeof error === 'function')? message:error;
        const errorType = (typeof error === 'function')? error:Error;

        const errorArg = this.callback.args[0][0];
        expect(errorArg).to.be.an.instanceof(errorType);

        if(errorMessage instanceof RegExp) {
            expect(errorArg.message).to.match(errorMessage);
        } else {
            expect(errorArg.message).to.equal(errorMessage);
        }

        return errorArg;
    }

    /**
     * Invokes the lamdba function, and pauses for some async action to take
     * place. Once the async action is completed, evaluates the callback
     * function for invocation with specific errors.
     *
     * @param {Object} error Reference to the expected error when the lambda
     *        function is invoked.
     * @param {Object} [message] An optional error message which will only be
     *        considered if the previous argument is an error type.
     *
     * @param {Object} errorArg The error argument received from the callback.
     */
    *testErrorAsync(error, message) {
        this.callback.reset();

        yield this.invoke();

        expect(this.callback).to.have.been.calledOnce;

        const errorMessage = (typeof error === 'function')? message:error;
        const errorType = (typeof error === 'function')? error:Error;

        const errorArg = this.callback.args[0][0];
        expect(errorArg).to.be.an.instanceof(errorType);

        if(errorMessage instanceof RegExp) {
            expect(errorArg.message).to.match(errorMessage);
        } else {
            expect(errorArg.message).to.equal(errorMessage);
        }

        return errorArg;
    }

    /**
     * Invokes the lamdba function, and evaluates the callback function for
     * successful invocation.
     *
     * @param {Object} error Reference to the expected error when the lambda
     *        function is invoked.
     *
     * @return {Object} The data returned by the callback.
     */
    testSuccess() {
        this.callback.reset();
        this.invoke();

        expect(this.callback).to.have.been.calledOnce;

        const errorArg = this.callback.args[0][0];
        expect(errorArg).to.be.null;

        const data = this.callback.args[0][1];
        return data;
    }

    /**
     * Invokes the lamdba function, and pauses for some async action to take
     * place. Once the async action is completed, evaluates the callback
     * function for successful invocation.
     *
     * @param {Object} error Reference to the expected error when the lambda
     *        function is invoked.
     *
     * @return {Object} The data returned by the callback.
     */
    *testSuccessAsync() {
        this.callback.reset();

        yield this.invoke();

        expect(this.callback).to.have.been.calledOnce;

        const errorArg = this.callback.args[0][0];
        expect(errorArg).to.be.null;

        const data = this.callback.args[0][1];
        return data;
    }
}

module.exports = LambdaWrapper;
