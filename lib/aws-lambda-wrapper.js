'use strict';

const _sinon = require('sinon');
const _chai = require('chai');
_chai.use(require('sinon-chai'));
_chai.use(require('chai-as-promised'));
const expect = _chai.expect;

const _clone = require('clone');
const AwsLambdaContext = require('./aws-lambda-context');

/**
 * Class that provides a wrapper around lambda handlers, and exposes utility
 * methods that can be used during testing.
 */
class AwsLambdaWrapper {
    /**
     * @param {Object} handler Reference to the lambda handler.
     * @param {Object} [event={}] The event object to pass to the handler
     *        when invoked.
     * @param {Object} [contextInfo = {
     *            functionName: "__lambda_function_name__",
     *            alias: null
     *        } ] Additional context info that will be used to generate the
     *        lambda context. If omitted, a default object will be generated.
     *        If the functionName property begins with "arn:", it will be
     *        used as specified. Otherwise, the name will be appended to an
     *        autogenerated arn prefix.
     */
    constructor(handler, event, contextInfo) {
        if(typeof handler !== 'function') {
            throw new Error('Invalid handler specified (arg #1)');
        }
        if(!event || typeof event !== 'object') {
            event = {};
        }
        this._handler = handler;
        this._event = _clone(event);
        this._callback = _sinon.spy();
        this._context = new AwsLambdaContext(contextInfo);
        this._ext = {
            logger: {
                info: _sinon.spy(),
                trace: _sinon.spy(),
                debug: _sinon.spy(),
                info: _sinon.spy(),
                warn: _sinon.spy(),
                error: _sinon.spy(),
                fatal: _sinon.spy(),
                child: function() {
                    return this._ext.logger;
                }
            },
            env: this._context.env,
            config: {
                get: _sinon.spy()
            }
        };
    }

    /**
     * Returns a reference to the extension object that would be passed into
     * the handler if a lambda wrapper is used.
     *
     * @return {Object} The extended properties object.
     */
    get ext() {
        return this._ext;
    }

    /**
     * Returns a reference to the callback spy that is passed to the lambda
     * function.
     */
    get callback() {
        return this._callback;
    }

    /**
     * Returns a reference to the context object that is passed to the lambda
     * function.
     */
    get context() {
        return this._context.context;
    }

    /**
     * Returns a reference to the event object that is passed to the lambda
     * function.
     */
    get event() {
        return this._event;
    }

    /**
     * Returns a reference to the lambda function handler.
     */
    get handler() {
        return this._handler;
    }

    /**
     * Invokes the lamdba function with predefined event, context and callback
     * values.
     */
    invoke() {
        this.handler(this.event, this.context, this.callback, this.ext);
    }

    /**
     * Invokes the lamdba function, and evaluates the callback function for
     * invocation with specific errors.
     *
     * @param {Object} error Reference to the expected error when the lambda
     *        function is invoked.
     */
    testError(error) {
        this.callback.reset();
        this.invoke();

        expect(this.callback).to.have.been.calledOnce;

        const errorArg = this.callback.args[0][0];
        expect(errorArg).to.be.an.instanceof(Error);
        if(error instanceof RegExp) {
            expect(errorArg.message).to.match(error);
        } else {
            expect(errorArg.message).to.equal(error);
        }
    }
}

module.exports = AwsLambdaWrapper;
