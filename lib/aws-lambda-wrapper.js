'use strict';

const _sinon = require('sinon');
const _chai = require('chai');
_chai.use(require('sinon-chai'));
_chai.use(require('chai-as-promised'));
const expect = _chai.expect;

const _clone = require('clone');
const AwsLambdaContext = require('./aws-lambda-context');

/**
 * Class that provides a wrapper around lambda handlers, and exposes utility
 * methods that can be used during testing.
 */
class AwsLambdaWrapper {
    /**
     * @param {Object} handler Reference to the lambda handler.
     * @param {Object} [event={}] The event object to pass to the handler
     *        when invoked.
     * @param {Object} [contextInfo = {
     *            functionName: "__lambda_function_name__",
     *            alias: null
     *        } ] Additional context info that will be used to generate the
     *        lambda context. If omitted, a default object will be generated.
     *        If the functionName property begins with "arn:", it will be
     *        used as specified. Otherwise, the name will be appended to an
     *        autogenerated arn prefix.
     * @param {Object} [config={}] Optional config parameters passed to the
     *        lambda as a part of the mock config object
     */
    constructor(handler, event, contextInfo, config) {
        if(typeof handler !== 'function') {
            throw new Error('Invalid handler specified (arg #1)');
        }
        if(!event || typeof event !== 'object') {
            event = {};
        }
        this._handler = handler;
        this._event = _clone(event);
        this._callback = _sinon.spy();
        this._context = new AwsLambdaContext(contextInfo);
        this._ext = this._initExt(config);
    }


    /**
     * Initializes the extension object.
     *
     * @private
     *
     * @param {Object} [props={}] Optional config props object that can be used
     *        to set properties for the lambda.
     */
    _initExt(props) {
        const logger = {};
        [ 'info', 'trace', 'debug', 'warn', 'error', 'fata' ].forEach((funcName) => {
            logger[funcName] = _sinon.spy();
        });
        logger.child = () => { return logger; };

        props = props || {};
        const config = _clone(props);
        config.get = (propPath) => {
            const reducer = (obj, propName) => {
                return (obj && typeof obj === 'object')? obj[propName]:obj;
            };
            propPath.split('.').reduce(reducer, obj);
        };

        return {
            logger: logger,
            config: config,
            env: this._context.env
        };
    }

    /**
     * Returns a reference to the extension object that would be passed into
     * the handler if a lambda wrapper is used.
     *
     * @return {Object} The extended properties object.
     */
    get ext() {
        return this._ext;
    }

    /**
     * Returns a reference to the callback spy that is passed to the lambda
     * function.
     */
    get callback() {
        return this._callback;
    }

    /**
     * Returns a reference to the context object that is passed to the lambda
     * function.
     */
    get context() {
        return this._context.context;
    }

    /**
     * Returns a reference to the event object that is passed to the lambda
     * function.
     */
    get event() {
        return this._event;
    }

    /**
     * Returns a reference to the lambda function handler.
     */
    get handler() {
        return this._handler;
    }

    /**
     * Invokes the lamdba function with predefined event, context and callback
     * values.
     */
    invoke() {
        this.handler(this.event, this.context, this.callback, this.ext);
    }

    /**
     * Invokes the lamdba function, and evaluates the callback function for
     * invocation with specific errors.
     *
     * @param {Object} error Reference to the expected error when the lambda
     *        function is invoked.
     */
    testError(error) {
        this.callback.reset();
        this.invoke();

        expect(this.callback).to.have.been.calledOnce;

        const errorArg = this.callback.args[0][0];
        expect(errorArg).to.be.an.instanceof(Error);
        if(error instanceof RegExp) {
            expect(errorArg.message).to.match(error);
        } else {
            expect(errorArg.message).to.equal(error);
        }
    }

    /**
     * Invokes the lamdba function, and pauses for some async action to take
     * place. Once the async action is completed, evaluates the callback
     * function for invocation with specific errors.
     *
     * @param {Object} error Reference to the expected error when the lambda
     *        function is invoked.
     */
    *testAsync (error) {
        this.callback.reset();
        this.invoke();

        yield 'Awaiting result';

        expect(this.callback).to.have.been.calledOnce;

        const errorArg = this.callback.args[0][0];
        expect(errorArg).to.be.an.instanceof(Error);
        if(error instanceof RegExp) {
            expect(errorArg.message).to.match(error);
        } else {
            expect(errorArg.message).to.equal(error);
        }
    }
}

module.exports = AwsLambdaWrapper;
