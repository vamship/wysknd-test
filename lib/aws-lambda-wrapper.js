'use strict';

const _sinon = require('sinon');
const _chai = require('chai');
_chai.use(require('sinon-chai'));
_chai.use(require('chai-as-promised'));
const expect = _chai.expect;

const _clone = require('clone');

const DEFAULT_ARN_PREFIX = 'arn:aws:lambda:__aws_region__:__aws_account__:function';
const DEFAULT_FUNCTION_NAME = '__function_name__';
const DEFAULT_FUNCTION_VERSION = '$LATEST';

/**
 * Class that provides a wrapper around lambda handlers, and exposes utility
 * methods that can be used during testing.
 */
class LambdaWrapper {
    /**
     * @param {Object} handler Reference to the lambda handler.
     * @param {Object} [event={}] The event object to pass to the handler
     *        when invoked.
     * @param {Object} [contextInfo = {
     *            functionName: "__lambda_function_name__",
     *            alias: null
     *        } ] Additional context info that will be used to generate the
     *        lambda context. If omitted, a default object will be generated.
     *        If the functionName property begins with "arn:", it will be
     *        used as specified. Otherwise, the name will be appended to an
     *        autogenerated arn prefix.
     */
    constructor(handler, event, contextInfo) {
        if(typeof handler !== 'function') {
            throw new Error('Invalid handler specified (arg #1)');
        }
        if(!event || typeof event !== 'object') {
            event = {};
        }
        this._handler = handler;
        this._event = _clone(event);
        this._callback = _sinon.spy();
        this._context = this._generateContext(contextInfo);
    }

    /**
     * Generates context information for the lambda.
     *
     * @private
     * @param {Object} contextInfo Properties that will help generate the
     *        context.
     *
     * @return {Object} The genrated context object.
     */
    _generateContext(contextInfo) {
        if(!contextInfo || typeof contextInfo !== 'object') {
            contextInfo = {};
        }
        contextInfo.functionName = contextInfo.functionName || DEFAULT_FUNCTION_NAME;
        contextInfo.invokedFunctionArn = contextInfo.invokedFunctionArn ||
                                `${DEFAULT_ARN_PREFIX}:${contextInfo.functionName}`;
        if(contextInfo.alias) {
            contextInfo.invokedFunctionArn= `${contextInfo.invokedFunctionArn}:${contextInfo.alias}`;
            delete contextInfo.alias;
        }
        const context = {};
        for(let prop in contextInfo) {
            context[prop] = contextInfo[prop];
        }
        return context;
    }

    /**
     * Returns a reference to the callback spy that is passed to the lambda
     * function.
     */
    get callback() {
        return this._callback;
    }

    /**
     * Returns a reference to the context object that is passed to the lambda
     * function.
     */
    get context() {
        return this._context;
    }

    /**
     * Returns a reference to the event object that is passed to the lambda
     * function.
     */
    get event() {
        return this._event;
    }

    /**
     * Returns a reference to the lambda function handler.
     */
    get handler() {
        return this._handler;
    }

    /**
     * Invokes the lamdba function with predefined event, context and callback
     * values.
     */
    invoke() {
        this._handler(this._event, this._context, this._callback);
    }

    /**
     * Invokes the lamdba function, and evaluates the callback function for
     * invocation with specific errors.
     *
     * @param {Object} error Reference to the expected error when the lambda
     *        function is invoked.
     */
    testError(error) {
        this._callback.reset();
        this._handler(this._event, this._context, this._callback);

        expect(this._callback).to.have.been.calledOnce;

        const errorArg = this._callback.args[0][0];
        expect(errorArg).to.be.an.instanceof(Error);
        if(error instanceof RegExp) {
            expect(errorArg.message).to.match(error);
        } else {
            expect(errorArg.message).to.equal(error);
        }
    }
}

module.exports = LambdaWrapper;
